<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最小二乘法]]></title>
    <url>%2F2018%2F05%2F01%2F%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在科学实验和工程设计中，往往需要利用一些离散点上的信息（或称为实验数据）$（x_i，y_i）$去寻找、确定$x$与$y$之间函数关系的某种近似表达式。从几何角度来看，就是利用给定的$m$个数据点$（x_i, y_i）= (1, 2, …, m)$，求曲线$y = f (x)$的一条近似曲线$y = φ(x)$。因此，这是一个曲线拟合问题。 &emsp;&emsp;插值法在一定程度上可以解决该问题，但是会有很大误差，不能反映原始问题的变化规律，缺乏实用价值。因此，我们可以使用叫做最小二乘法的曲线拟合方法。 编程过程&emsp;&emsp;编程的关键在于构建最小二乘法的正规方程组（法方程组），我们先来看看正规方程组：$$\left[\begin{matrix}m+1 &amp; \sum\limits_{i=0}^mx_i &amp; \cdots &amp; \sum\limits_{i=0}^mx_i^n \\\sum\limits_{i=0}^mx_i &amp; \sum\limits_{i=0}^mx_i^2 &amp; \cdots &amp; \sum\limits_{i=0}^mx_i^{n+1} \\\vdots &amp; \vdots &amp; &amp; \vdots \\\sum\limits_{i=0}^mx_i^n &amp; \sum\limits_{i=0}^mx_i^{n+1} &amp; \cdots &amp; \sum\limits_{i=0}^mx_i^{2n}\end{matrix}\right]\left[ \begin{matrix} a_0 \\ a_1 \\ \vdots \\ a_n \end{matrix}\right] =\left[ \begin{matrix} \sum\limits_{i=0}^my_i \\ \sum\limits_{i=0}^mx_iy_i \\ \vdots \\ \sum\limits_{i=0}^mx_i^ny_i \end{matrix}\right]$$&emsp;&emsp;根据观察，我们仅需要存储$[\sum\limits_{i=0}^mx_i, \sum\limits_{i=0}^mx_i^2, …, \sum\limits_{i=0}^mx_i^{2n}]、[\sum\limits_{i=0}^my_i, \sum\limits_{i=0}^mx_iy_i, …, \sum\limits_{i=0}^mx_i^ny_i]$即可，因此写出构建矩阵的函数：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556"""@brief: 计算sum_x, sum_x^2, sum_x^3, ..., sum_x^n@parameter: xi 所有插值节点的横坐标@parameter: times 拟合次数@notice: sum_xims数组第一个应改为M+1即所有插值节点的个数@return: 求出的sum_xims数组"""def sum_xim(xi, times): sum_xims = [len(xi)] # print(sum_xims) sum_xi = 0 for mm in range(1, 2*times+1): for i in range(0, len(xi)): sum_xi += xi[i]**mm sum_xims.append(sum_xi) sum_xi = 0 # print(sum_xims) return sum_xims"""@brief: 计算sum_y, sum_[x*y], sum_[x^2*y], ..., sum_[x^mm*y]@parameter: xi 所有插值节点的横坐标@parameter: yi 所有插值节点的纵坐标@parameter: times 拟合次数@return: 求出的sum_yims数组"""def sum_yim(xi, yi, times): sum_yims = [] sum_yi = 0 for mm in range(0, times+1): for i in range(0, len(yi)): sum_yi += xi[i]**mm * yi[i] sum_yims.append(sum_yi) sum_yi = 0 # print(sum_yims) return sum_yims"""@brief: 将求出的sum_xims数组转换成公式中的系数矩阵@parameter: sum_x sum_xim()函数中求出的sum_xims数组@parameter: k 迭代次数@return: 生成的系数矩阵"""def generating_matrix(sum_x, k): result = [] for j in range(0, k+1): result.append(sum_x[j:j+k+1]) return result &emsp;&emsp;代码的剩余部分就很好写了，构建好后，我们使用LU分解法解这个方程。我们给出其代码： 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import LU分解"""@todo: 最小二乘法，使用LU分解法计算a0, a1, ..., an@parameter: xi 所有插值节点的横坐标@parameter: fi 所有插值节点的纵坐标@return: lsm()函数"""def least_square_method(xi=None, fi=None): if fi is None: fi = [] if xi is None: xi = [] def lsm(x): A = generating_matrix(sum_xim(xi, x), x) B = sum_yim(xi, fi, x) # print(A, B) result = LU分解.methodLU(A, B, len(A)) r = square_error(xi, fi, result, x) print_it(result, r, x) return lsmdef is_num(s): # 判断输入的字符是否为一个数 try: float(s) return True except ValueError: return False"""@brief: 计算sum_x, sum_x^2, sum_x^3, ..., sum_x^n@parameter: xi 所有插值节点的横坐标@parameter: times 拟合次数@notice: sum_xims数组第一个应改为M+1即所有插值节点的个数@return: 求出的sum_xims数组"""def sum_xim(xi, times): sum_xims = [len(xi)] # print(sum_xims) sum_xi = 0 for mm in range(1, 2*times+1): for i in range(0, len(xi)): sum_xi += xi[i]**mm sum_xims.append(sum_xi) sum_xi = 0 # print(sum_xims) return sum_xims"""@brief: 计算sum_y, sum_[x*y], sum_[x^2*y], ..., sum_[x^mm*y]@parameter: xi 所有插值节点的横坐标@parameter: yi 所有插值节点的纵坐标@parameter: times 拟合次数@return: 求出的sum_yims数组"""def sum_yim(xi, yi, times): sum_yims = [] sum_yi = 0 for mm in range(0, times+1): for i in range(0, len(yi)): sum_yi += xi[i]**mm * yi[i] sum_yims.append(sum_yi) sum_yi = 0 # print(sum_yims) return sum_yims"""@brief: 将求出的sum_xims数组转换成公式中的系数矩阵@parameter: sum_x sum_xim()函数中求出的sum_xims数组@parameter: k 迭代次数@return: 生成的系数矩阵"""def generating_matrix(sum_x, k): result = [] for j in range(0, k+1): result.append(sum_x[j:j+k+1]) return result"""@brief: 求出最小二乘法的平方误差"""def square_error(xi, yi, ak, times): sum_yi_in_se = 0 sum_xy = 0 sum_akxy = 0 for i in range(0, len(xi)): sum_yi_in_se += yi[i] ** 2 # print("yi", yi[i]) for k in range(0, times+1): for j in range(0, len(xi)): sum_xy += xi[j]**k*yi[j] # print("xi[j]+k+yi[j]", xi[j], k, yi[j]) sum_akxy += ak[k]*sum_xy # print("ak", ak[k]) sum_xy = 0 r = sum_yi_in_se - sum_akxy return rdef print_it(ans, se, times): print("P_", end="") print(times, end="") print("(x) = ", end="") for i in range(0,len(ans)): print(ans[i], "*x^", end="") print(i, "+", end="") print("0\n平方误差为：", se)if __name__ == '__main__': xs = [] fxs = [] print("请依次输入x和f(x)，按任意其他字符结束：") m = input() n = input() while is_num(m) and is_num(n): xs.append(float(m)) fxs.append(float(n)) m = input() if not is_num(m): break n = input() F = least_square_method(xs, fxs) try: number = int(input("请输入要求拟合的次数：")) if number &gt; 0: F(number) else: print("您输入的值有误") except ValueError: print("您输入的值有误") 心得体会&emsp;&emsp;这整次数值实验对我的帮助很大。这也是我第一次使用Python编写实验。这次实验，不仅让我能够更加熟练的运用Python，而且让我较深入地了解了数值分析这门课程，让我感受到了数值分析的有趣，魅力。&emsp;&emsp;由于课时的原因，我们并不能上完整本书，但是我会在课余时间继续学习这门课程，相信他会给我的学习、工作带来很大裨益！&emsp;&emsp;感谢老师给我们上课，老师课堂风格十分让我喜欢，感谢您！]]></content>
      <tags>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛顿插值法]]></title>
    <url>%2F2018%2F05%2F01%2F%E7%89%9B%E9%A1%BF%E6%8F%92%E5%80%BC%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在我们的实验中常常有这样的问题：我们得到了一系列某个函数$y=f(x)$在$x_0, x_1, …, x_n$处的值$y_0, y_1, …, y_n$，但是他的函数解析式我们不知道。这时候我们需要构造一个$P(x)$作为$y=f(x)$的近似表达式；或者他的解析式太过复杂，需要一个易于计算的、简单的函数$P(x)$去近似代替他。而插值法就是建立这种近似公式的基本方法。 牛顿插值法&emsp;&emsp;拉格朗日插值公式有一定规律，但是实践发现，当我们增加一个节点的时候，不仅要增加项数，而且以前各项也必须重新全部计算，这样就带来了很多麻烦，有没有一种插值方法，能够利用之前已有的结果，而不需要重新计算呢？答案是有的，那就是牛顿插值法。 编程过程&emsp;&emsp;现在主要讲一下牛顿插值法的编程过程。&emsp;&emsp;首先看一下牛顿插值公式：$$\begin{cases}L_n(x) = f(x_0)+f[x_0,x_1]ω_1(x)+…+f[x_0,x_1,…,x_n]ω_n(x) \\ω_n(x) = (x-x_0)(x-x_1)(x-x_2)…(x-x_{n-1})\end{cases}$$&emsp;&emsp;可以看出，编写程序的关键，就是解决构造差商的函数，我们看一下差商的计算公式：$$f[x_0,x_1,…,x_n] = \sum\limits_{i=0}^n\frac{f(x_i)}{(x_i-x_0)…(x_i-x_{i-1})(x_i-x_{i+1})…(x_i-x_n)}=\frac{f[x_0,x_1,…,x_{n-1}]-f[x_1,x_2,…,x_n]}{x_0-x_n}$$&emsp;&emsp;通过公式，我们很容易能想到使用递归来实现这个功能：12345678910111213141516"""@todo: 使用递归求差商(n阶差商)@parameter: x 数组，存储所有插值节点的x坐标@parameter: fx 数组，存储所有插值节点的y坐标@note: 注意下标和公式中下标的区别。 注意防止栈溢出@return: 返回f(x)的 len(x)-1 阶差商"""def difference_quotient(x, fx): if len(x) &gt; 2 and len(fx) &gt; 2: return (difference_quotient(x[:len(fx)-1], fx[:len(fx)-1]) - difference_quotient(x[1:len(fx)], fx[1:len(fx)]))/(x[0]-x[-1]) else: return (fx[0] - fx[1])/(x[0] - x[1]) 接下来就要求$ω_n(x)$，这个看公式照写就可以：123456789101112131415161718"""@todo: 求W_i(x) [W_i(x) = Π(x-x_i) from i = 0 to n]@parameter: i i次多项式@parameter: xi 所有插值节点的x坐标@return: 返回wi(x)函数"""def find_wi(i=0, xi=None): if xi is None: xi = [] def wi(x): ans = 1.0 for item in range(i): ans *= (x - xi[item]) # W_i累乘 return ans return wi 剩下的步骤就更简单了，牛顿插值法的优点就是当添加一个节点时，只需要再增加一项就可以了，而且它还节省了运算次数（尤其是乘法）。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091"""@todo: 使用递归求差商(n阶差商)@parameter: x 数组，存储所有插值节点的x坐标@parameter: fx 数组，存储所有插值节点的y坐标@note: 注意下标和公式中下标的区别。 注意防止栈溢出@return: 返回f(x)的 len(x)-1 阶差商"""def difference_quotient(x, fx): if len(x) &gt; 2 and len(fx) &gt; 2: return (difference_quotient(x[:len(fx)-1], fx[:len(fx)-1]) - difference_quotient(x[1:len(fx)], fx[1:len(fx)]))/(x[0]-x[-1]) else: return (fx[0] - fx[1])/(x[0] - x[1])"""@todo: 求W_i(x) [W_i(x) = Π(x-x_i) from i = 0 to n]@parameter: i i次多项式@parameter: xi 所有插值节点的x坐标@return: 返回wi(x)函数"""def find_wi(i=0, xi=None): if xi is None: xi = [] def wi(x): ans = 1.0 for item in range(i): ans *= (x - xi[item]) # W_i累乘 return ans return wi"""@todo: 将差商和wi结合获得牛顿插值函数N(x)"""def find_newton_interpolation(xi=None, fi=None): if fi is None: fi = [] if xi is None: xi = [] def newton_interpolation(x): ans = fi[0] for i in range(2, len(xi)): w = find_wi(i-1, xi) dq = difference_quotient(xi[:i], fi[:i]) ans += (dq * w(x)) return ans return newton_interpolation"""@brief: 判断输入的是否是一个数"""def is_num(s): try: float(s) return True except ValueError: return Falseif __name__ == '__main__': xs = [] fxs = [] print("请依次输入x和f(x)，按任意其他字符结束：") m = input() n = input() while is_num(m) and is_num(n): xs.append(float(m)) fxs.append(float(n)) m = input() if not is_num(m): break n = input() F = find_newton_interpolation(xs, fxs) try: number = float(input("请输入要求近似值的x值：")) print("F(", number, ")的近似值为：", F(number)) except ValueError: print("您输入的值有误")]]></content>
      <tags>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解线性方程组的迭代法]]></title>
    <url>%2F2018%2F04%2F24%2F%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;对于阶数不高的方程组，直接法非常有效，对于阶数高，而系数矩阵稀疏的线性方程组却存在着困难，在这类矩阵中，非零元素较少，若用直接法求解，就要存贮大量零元素。为减少运算量、节约内存，使用迭代法更有利。 雅可比迭代法&emsp;&emsp;设有方程组$$\sum\limits_{j=1}^{n}a_{ij}x_{j} = b_i, (i=1, 2, …, n)$$简记为：$Ax=b$。其中$A$为非奇异阵且$a_ii≠0 (i = 1, 2, …, m)$。考虑$Ax=b$的第$i$个方程解出$x_i$，得到$$x_i =\frac{1}{a_{ii}} (b_i-\sum\limits_{j=1,j≠i}^{n}a_{ij}x_{j})(i=1, 2, …, n)$$对该方程组应用迭代法，即得解方程组Ax=b的雅可比迭代公式$$\begin{cases}x_i^{(k+1)} =\frac{1}{a_{ii}}(b_i-\sum\limits_{j=1,j≠i}^{n}a_{ij}x_{j}^{(k)}) \\i=1,2,…,n \\k=0,1,…\end{cases}$$其中$$x^{(k)} = (x_1^{(k)}, x_2^{(k)}, …, x_n^{(k)})^T\tag{*}$$如果$(*)$收敛于$x^{*} = (x_1^{*}, x_2^{*}, …, x_n^{*})^T$，则$x_i^*(i=1, 2, …, n)$就是该方程组的解。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778"""@brief: 判断迭代停止的条件@param: xx 传入方程组的解@return: 若解向量xx最近两组解的1范数差大于误差限，返回True（继续迭代）； 否则返回False（停止迭代）@notice: 注意下标和公式中下标的区别。"""def judge(xx): x1_sum = 0 x2_sum = 0 e = 0.5 * 10 ** (-5) for iii in range(0, len(xx[-1]), 1): x1_sum += xx[-1][iii] for iii in range(0, len(xx[-2]), 1): x2_sum += xx[-2][iii] if (abs((x1_sum-x2_sum) / len(xx[-1]))) &gt; e: return True else: print("误差：", (x1_sum-x2_sum) / len(xx[-1]), "&lt; e =", e) return False"""@brief: 雅可比迭代法核心代码@param: A 用户输入的系数矩阵A@param: b 用户输入的线性方程组中的b组成的向量。@param: n 用户输入方程的个数@notice: 注意下标和公式中下标的区别。"""def jacobi(A, b, n): j_sum = 0 x = [] xk = [0, 0, 0] x.append(xk.copy()) xk.clear() for ii in range(0, n, 1): # 需要在循环外先进行一次迭代 for jj in range(0, n, 1): j_sum += A[ii][jj] * x[-1][jj] xk.append(float((1 / A[ii][ii]) * (b[ii] - j_sum))) j_sum = 0 x.append(xk.copy()) xk.clear() while judge(x): # 迭代公式 for ii in range(0, n, 1): for jj in range(0, n, 1): if ii != jj: j_sum += A[ii][jj]*x[-1][jj] xk.append(float((1 / A[ii][ii]) * (b[ii] - j_sum))) # 迭代公式 j_sum = 0 x.append(xk.copy()) xk.clear() for item in range(0, len(x), 1): print("第", item, "次迭代：", x[item])if __name__ == '__main__': A = [] A_row = [] b = [] Z = [] n = int(input("您要输入的方程个数：")) print("请输入A：") for i in range(0, n, 1): for j in range(0, n, 1): A_row.append(float(input())) A.append(A_row.copy()) A_row.clear() print("请输入b：") for k in range(0, n, 1): b.append(float(input())) Z.append(A[k].copy()) Z[-1].append(b[-1]) jacobi(A, b, n) 高斯-赛德尔迭代法&emsp;&emsp;显然，如果我们稍微改动一下雅可比迭代公式，让它变成这样：$$\begin{cases}x_i^{(k+1)} =\frac{1}{a_{ii}}(b_i-\sum\limits_{j=1}^{i-1}a_{ij}x_{j}^{(k+1)}-\sum\limits_{j=i+1}^{n}a_{ij}x_{j}^{(k)}) \\i=1,2,…,n \\k=0,1,…\end{cases}$$&emsp;&emsp;在进行迭代的时候会获得更好的效果，因为我们通过这个式子，把$x_i^{(k+1)}$及时地带入迭代过程中去，而$x_i^{(k+1)}$比$x_i^{(k)}$更接近原方程的解。&emsp;&emsp;这就叫做高斯-赛德尔迭代法 完整代码&emsp;&emsp;以下则是运用高斯赛德尔迭代法写的解线性方程组的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788"""@brief: 判断迭代停止的条件@param: xx 传入方程组的解@return: 若解向量xx最近两组解的1范数差大于误差限，返回True（继续迭代）； 否则返回False（停止迭代）@notice: 注意下标和公式中下标的区别。"""def judge(xx): x1_sum = 0 x2_sum = 0 e = 0.5 * 10 ** (-5) for iii in range(0, len(xx[-1]), 1): x1_sum += xx[-1][iii] for iii in range(0, len(xx[-2]), 1): x2_sum += xx[-2][iii] if (abs((x1_sum-x2_sum) / len(xx[-1]))) &gt; e: return True else: return False"""@brief: 高斯-赛德尔迭代法核心代码@param: A 用户输入的系数矩阵A@param: b 用户输入的线性方程组中的b组成的向量。@param: n 用户输入方程的个数@notice: 注意下标和公式中下标的区别。"""def gauss_seidel(A, b, n): g1_sum = 0 g2_sum = 0 x = [] xk = [0, 0, 0] x.append(xk.copy()) xk.clear() for ii in range(0, n, 1): # 需要在循环外先进行一次迭代 for jj in range(0, n, 1): if jj &lt;= ii-1: g1_sum += A[ii][jj]*xk[jj] else: if jj != ii: g2_sum += A[ii][jj]*x[-1][jj] xk.append(float((1 / A[ii][ii]) * (b[ii] - g1_sum - g2_sum))) g1_sum = 0 g2_sum = 0 x.append(xk.copy()) xk.clear() while judge(x): for ii in range(0, n, 1): for jj in range(0, n, 1): if jj &lt;= ii - 1: g1_sum += A[ii][jj] * xk[jj] else: if jj != ii: g2_sum += A[ii][jj] * x[-1][jj] xk.append(float((1 / A[ii][ii]) * (b[ii] - g1_sum - g2_sum))) # 迭代公式 g1_sum = 0 g2_sum = 0 x.append(xk.copy()) xk.clear() for item in range(0, len(x), 1): # 输出步进结果 print("第", item, "次迭代：", x[item])if __name__ == '__main__': A = [] A_row = [] b = [] Z = [] n = int(input("您要输入的方程个数：")) print("请输入A：") for i in range(0, n, 1): for j in range(0, n, 1): A_row.append(float(input())) A.append(A_row.copy()) A_row.clear() print("请输入b：") for k in range(0, n, 1): b.append(float(input())) Z.append(A[k].copy()) Z[-1].append(b[-1]) gauss_seidel(A, b, n)]]></content>
      <tags>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解线性方程组的直接方法]]></title>
    <url>%2F2018%2F04%2F17%2F%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;许多科学技术问题要归结为解含有多个未知量$x_1, x_2, …, x_n$的线性方程组。例如，用最小二乘法求实验数据的曲线拟合问题等等，这些问题最后都归结为求解线性代数方程组。关于线性方程组的数值解法一般有两类：直接法和迭代法。这次实验主要介绍两种解线性方程组的直接法。 &emsp;&emsp;直接法就是经过有限步算术运算，可求得线性方程组精确解的方法（假设计算过程中没有舍入误差）。但实际计算中由于舍入误差的存在和影响，这种方法也只能求得线性方程组的近似解。 方法一：高斯消元法&emsp;&emsp;高斯消元法是解线性方程组最常用的方法之一，它的基本思想是通过逐步消元，把方程组化为系数矩阵为三角形矩阵的同解方程组，然后用回代法解此三角形方程组得原方程组的解。&emsp;&emsp;限于篇幅限制，本文直接开始讨论一般形式线性方程组的解法（为了描述方便，本文讨论的方程组的系数行列式不等于零）： 消元过程&emsp;&emsp;目标：消元过程将所给方程组加工成上三角形方程组&emsp;&emsp;消元公式：$$\begin{cases}a_{kj}^{(k)}=\frac{a_{kj}^{(k-1)}}{a_{kk}^{(k-1)}} j=k,k+1,…,n+1 \\a_{ij}^{(k)}=a_{ij}^{(k-1)}-a_{ik}^{(k-1)}·a_{kj}^{(k)} \\j=k+1,…,n+1 \\i=k+1,…,n\end{cases}$$&emsp;&emsp;根据消元公式编写消元代码如下：12345678910111213141516171819202122232425262728293031'''@brief: 将传入的矩阵进行初等变换，转换为上三角矩阵。@param: a 用户输入的系数矩阵A@param: b 用户输入的线性方程组中的b组成的向量。@param: i 传递进来当前处理的行数@param: n A数组的长度@return: 转化完毕的a,b@notice: 注意下标和公式中下标的区别。'''def convert(a, b, i, n): # print(i, n) if i + 1 != n: for j in range(i+1, n, 1): d = a[j][i] e = a[i][i] for m in range(i, n, 1): # print("j,m", j, m) f = a[i][m] s = f * d / e # print(a[j][m], 's', s, a[i][m], a[j][i], a[i][i]) a[j][m] = a[j][m] - s # 高斯消元法变换A矩阵 b[j] = b[j] - b[i] * d / e # 将B矩阵的数也进行变换 print("Times:", i+1) print("A:") print(A) print("B:") print(b) print("\n\n") return a, b 回代过程&emsp;&emsp;目标：经回代过程求解方程组的解。&emsp;&emsp;回代公式：$$\begin{cases}x_n = a_{n,n+1}^{(n)} \\x_k = a_{k,n+1}^{(k)} - \sum\limits_{j=k+1}^na_{kj}^{(k)}x_j \\k=n-1,…,1\end{cases}$$&emsp;&emsp;根据回代公式编写的代码如下：123456789101112131415161718192021222324252627282930'''@brief: 将转换好的矩阵进行回代得出解。@param: a 转化之后的系数矩阵A@param: b 转化之后的线性方程组中的b组成的向量。@return: 线性方程组的解数组x@notice: 注意下标和公式中下标的区别。'''def calculate(a, b): # print(a, b) h = len(b) - 1 # print('h', h) m = 0 summ = 0 x = [b[h]/a[h][h]] # print('x', x) for i in range(h-1, -1, -1): for j in range(h, i, -1): # print("i,j", i, j) summ = summ + a[i][j]*x[m] # print("summ", summ) m += 1 # print(m) m = 0 # print("i bi summ aii", i, b[i], summ, a[i][i]) x.append(float((b[i] - summ)/(a[i][i]))) # 回代公式 summ = 0 print("Result:[an, ..., a2, a1]:\n", x) return x 高斯消元法的工作量&emsp;&emsp;下面，我们统计一下高斯消元法的工作量，回代公式的第一个式子，每一次执行需要$n-(n-k)$次除法，第二个式子，每执行一次需要$[n-(k-1)]×(n-k)$次除法。因此在消元过程中，共需要$$\sum_{k=1}^n[(n-k+1)×(n-k)+(n-k+1)]=\sum_{k=1}^n(n-k+1)^2=\frac{1}{6}n(n+1)(2n+1)$$次除法。此外，回代过程共有$$\sum_{k=1}^n(n-k)=\frac{n}{2}(n-1)$$次乘法，汇总在一起，高斯消元法的计算量为：$$\frac{n^3}{3}+n^2-\frac{n}{3}$$次乘除法。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798def change(A, b, i, n): print("需要转换矩阵")'''@brief: 将传入的矩阵进行初等变换，转换为上三角矩阵。@param: a 用户输入的系数矩阵A@param: b 用户输入的线性方程组中的b组成的向量。@param: i 传递进来当前处理的行数@param: n A数组的长度@return: 转化完毕的a,b@notice: 注意下标和公式中下标的区别。'''def convert(a, b, i, n): # print(i, n) if i + 1 != n: for j in range(i+1, n, 1): d = a[j][i] e = a[i][i] for m in range(i, n, 1): # print("j,m", j, m) f = a[i][m] s = f * d / e # print(a[j][m], 's', s, a[i][m], a[j][i], a[i][i]) a[j][m] = a[j][m] - s # 高斯消元法变换A矩阵 b[j] = b[j] - b[i] * d / e # 将B矩阵的数也进行变换 print("Times:", i+1) print("A:") print(A) print("B:") print(b) print("\n\n") return a, b'''@brief: 将转换好的矩阵进行回代得出解。@param: a 转化之后的系数矩阵A@param: b 转化之后的线性方程组中的b组成的向量。@return: 线性方程组的解数组x@notice: 注意下标和公式中下标的区别。'''def calculate(a, b): # print(a, b) h = len(b) - 1 # print('h', h) m = 0 summ = 0 x = [b[h]/a[h][h]] # print('x', x) for i in range(h-1, -1, -1): for j in range(h, i, -1): # print("i,j", i, j) summ = summ + a[i][j]*x[m] # print("summ", summ) m += 1 # print(m) m = 0 # print("i bi summ aii", i, b[i], summ, a[i][i]) x.append(float((b[i] - summ)/(a[i][i]))) # 回代公式 summ = 0 print("Result:[an, ..., a2, a1]:\n", x) return xif __name__ == '__main__': r = [] B = [] A = [] N = 1 c = 0 first = True while c-1 != N: ii = input("请输入下一行，输入“n”以结束\n") while ii != 'n': r.append(float(ii)) ii = input() if first is True: c = len(r) # 判断输入矩阵是几阶矩阵 N = 0 first = False B.append(r[-1]) del r[-1] A.append(r[:]) N += 1 r.clear() N = len(A) for ii in range(0, N, 1): if A[ii][ii] != 0: convert(A, B, ii, N) # 判断当前转换的主元素是否为零，不为零则继续转换 else: change(A, B, ii, N) calculate(A, B) 方法二：LU分解法$A=LU$称为矩阵的三角分解，其中L为下三角阵，U为上三角阵，解方程组$Ax=b$等价于解两个三角方程组$$\begin{cases}Ly=b \\Ux=y\end{cases}$$这称为求解方程组的直接三角分解法。$$L=\left[ \begin{matrix} 1 \\ l_{21} &amp; 1 \\ \vdots &amp; \vdots &amp; \ddots \\ l_{n1} &amp; l_{n2} &amp; \cdots &amp; 1 \end{matrix}\right]&emsp;&emsp;U=\left[ \begin{matrix} u_{11} &amp; u_{12} &amp;\cdots &amp; u_{1n} \\ &amp; u_{22} &amp;\cdots &amp; u_{2n} \\ &amp; &amp;\ddots &amp; \vdots \\ &amp; &amp; &amp; u_{nn} \\ \end{matrix}\right]$$ 计算公式$$\begin{cases}u_{1j} = a_{1j}, j=1,2,…,n \\l_{i1} = \frac{a_{i1}}{u_{11}}, j=2,3,…,n \\u_{kj} = a_{kj} - \sum\limits_{i=1}^{k-1}l_{kj}u_{kj}, \\j=k, k+1, …, n; k=2, 3, …, n \\l_{ik} = \frac{a_{ik} - \sum\limits_{i=1}^{k-1}l_{ij}u_{jk}}{u_{kk}}\end{cases}$$ 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384def change(A, b, i, n): print("需要转换矩阵")'''@brief: 将传入的矩阵进行LU分解，并进行回代求出方程组的解。@param: A 用户输入的系数矩阵A@param: B 用户输入的线性方程组中的b组成的向量。@param: n A的长度@return: 返回解数组x@notice: 注意下标和公式中下标的区别。'''def methodLU(A, B, n): U = [[0 for col in range(n)] for row in range(n)] L = [[0 for col in range(n)] for row in range(n)] x = [0 for col in range(n)] y = [0 for col in range(n)] sum_y = 0 sum_x = 0 sum_lulu = 0 sum_lu = 0 for j in range(1, n+1, 1): U[0][j-1] = A[0][j-1] # U_1j = a_1j for i in range(2, n+1, 1): L[i-1][0] = float(A[i-1][0]/U[0][0]) # L_i1 = a_i1 / U_11 for k in range(2, n+1, 1): for j in range(k, n+1, 1): for i in range(1, k, 1): sum_lu = sum_lu + L[k-1][i-1]*U[i-1][j-1] U[k-1][j-1] = A[k-1][j-1] - sum_lu # 按公式计算U_kj并存储在数组中 sum_lu = 0 for i in range(k + 1, n+1, 1): for j in range(1, k, 1): sum_lulu = sum_lulu + L[i-1][j-1]*U[j-1][k-1] L[i-1][k-1] = (A[i-1][k-1] - sum_lulu) / U[k-1][k-1] # 按公式计算L_ik并存储在数组中 sum_lulu = 0 for nn in range(0, n, 1): L[nn][nn] = 1.0 if __name__ == '__main__': print("L:", L, "\nU:", U) y[0] = B[0] for k in range(2, n+1, 1): for j in range(1, k, 1): sum_y = sum_y + L[k-1][j-1]*y[j-1] y[k-1] = B[k-1] - sum_y # Ly=b，计算y并存储在数组中 sum_y = 0 # print(y) x[n-1] = y[n-1]/U[n-1][n-1] for k in range(n-1, 0, -1): for j in range(k+1, n+1, 1): sum_x = sum_x + U[k-1][j-1]*x[j-1] x[k-1] = (y[k-1] - sum_x) / U[k-1][k-1] # Ux=y, 计算x并存储在数组中 sum_x = 0 return xif __name__ == '__main__': r = [] B = [] A = [] N = 1 c = 0 first = True while c-1 != N: ii = input("请输入下一行，输入“n”以结束\n") while ii != 'n': r.append(float(ii)) ii = input() if first is True: c = len(r) N = 0 first = False B.append(r[-1]) del r[-1] A.append(r[:]) N += 1 r.clear() N = len(A) x = methodLU(A, B, N) print("Result:[x1, x2, ..., xn]:\n", x)]]></content>
      <tags>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法&牛顿法]]></title>
    <url>%2F2018%2F04%2F10%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分法基本思想 &emsp;&emsp;二分法的基本思想，就是将方程根所在的区间平分为两个小区间，再判断根属于哪个小区间；把有根的小区间再平分为二，再判断根所在的更小的区间，对分；重复这一过程，最后求出所要的近似值。 执行步骤&emsp;&emsp;1. 计算$f(x)$在有解区间$[a,b]$端点处的值，$f(a)$，$f(b)$。&emsp;&emsp;2. 计算$f(x)$在区间中点$x_1 = \frac{a+b}{2}$处的值$f(x_1)$。&emsp;&emsp;3. 判断若$f(x_1)=0$，则$x_1 = \frac{a+b}{2}$即是根，否则检验：&emsp;&emsp;&emsp;&emsp;(1) 若$f(x_1)$与$f(a)$异号，则知解位于区间$[a, x_1]$，以$x_1$代替$b$；&emsp;&emsp;&emsp;&emsp;(2) 若$f(x_1)$与$f(a)$同号，则知解位于区间$[x_1, b]$，$x_1$代替$a$。&emsp;&emsp;反复执行步骤2、3，便可得到一系列有根区间:$$(a, b), (a_1, b_1), …, (a_k, b_k), …$$&emsp;&emsp;其中每个区间都是前一个区间的一半，因此区间长度为$$b_k-a_k=\frac{1}{2^k}(b-a)$$&emsp;&emsp;显然，二分过程如果能够无限地继续下去，这些区间最终必收敛于一点$x^*$，该点就是所求的根。&emsp;&emsp;当然，我们很清楚无限地继续实际上是不可能的，也没必要.$$|x_k-x^*|≤\frac{1}{2}(b_k-a_k)=b_{k+1}-a_{k+1}$$&emsp;&emsp;只要有根区间$(a_{k+1},b_{k+1})$的长度小于预先给定的误差$ε$,那么就可以取$$x_{k+1}=\frac{1}{2}(a_k+b_k)$$&emsp;&emsp;作为所求根$x^*$的第$k+1$次近似值。其误差估计为：$$|x^*-x_{k+1}|≤\frac{1}{2^{k+1}}(b-a)$$ 实验代码&emsp;&emsp;根据步骤写出的二分法的源代码：123456789101112131415161718192021222324252627282930313233343536373839404142from texttable import Texttabledef f(x): # 定义f(x) result = x ** 3 + 4 * x ** 2 - 10 return resulttable = Texttable()table.set_precision(13)table.set_cols_dtype(['i', 'f', 'f', 'f', 'f'])table.set_cols_align(["l", "r", "r", "r", "r"])if __name__ == '__main__': e = 0.5 * 10 ** (-5) an = 1 bn = 2 n = 1 xn = (bn + an) / 2 # print(n, ':', (bn - an) / 2) if f(an) * f(bn) &lt; 0: # 判断f(a) x f(b)是否小于零 table.add_rows([["n", "a_n", "b_n", "x_n", "f(x_n)"]]) table.add_row([n, an, bn, xn, f(xn)]) while (bn - an) / 2 &gt; e: # 判断误差/精度值 if f(xn) * f(an) &lt; 0: # 判断左端点和插入点的函数值相乘是否小于零 n += 1 bn = xn xn = (bn + an) / 2 # xn是a与b的中点 table.add_row([n, an, bn, xn, f(xn)]) # print(n, ':', (bn - an) / 2) else: # 否则证明根在右区间 n += 1 an = xn xn = (bn + an) / 2 table.add_row([n, an, bn, xn, f(xn)]) # print(n, ':', (bn - an) / 2) else: print("方程在区间 (", an, ",", bn, ") 无根.") print("程序迭代", n, "次，近似根 x _", n, "=", xn, "即为所求，其误差：\n", "|x* - xn| &lt; (b _", n, "- a _", n, ")/2 =", (bn - an) / 2, "&lt; 0.5e-05。\n计算结果如下：") print(table.draw()) 牛顿法 牛顿法是求解方程$f(x)=0$的一种重要的迭代法。它是一种将非线性方程$f(x)=0$逐步线性化的方法，是解代数方程和超越方程的有效方法之一。 牛顿法的迭代公式&emsp;&emsp;牛顿迭代法是一种特殊的不动点迭代法，其计算公式为$$x_{k+1}=x_{k}-\frac{f(x_k)}{f’(x_k)}, k=0,1,2,…$$&emsp;&emsp;其迭代函数为$$φ(x)=x-\frac{f(x)}{f’(x)}$$&emsp;&emsp;至于牛顿法的误差估计，在求根的过程中，$x^*$是不知道的，因此不可能用$|x^*-x_k|&lt;ε$来作为迭代结束的条件，我们可以采用$|x_{k+1}-x_k|&lt;ε$来控制迭代过程的结束（证明略） 实验代码&emsp;&emsp;根据迭代公式写出的二分法的源代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445from texttable import Texttabletable = Texttable()table.set_precision(13)table.set_cols_dtype(['i', 'f'])table.set_cols_align(["l", "r"])table.add_rows([["n", "x_n"]])def f(x1): return x1**3 + 4*x1**2 - 10 # 函数f(x)def f1(x2): return 3*x2**2 + 8*x2 # f(x)的导数f'(x)'''@brief: 使用牛顿法计算非线性方程f(x)的解。@param: x 所有解的集合。@param: e 用户输入的精度值（误差限）。@notice: 注意到在判断误差时需要使用到两个数据，因此需要在循环开始前先添加一组初始数据。'''def newton(x, e): n = 0 # 迭代次数计数器 table.add_row([n, x[-1]]) x.append(x[-1]-f(x[-1])/f1(x[-1])) n += 1 table.add_row([n, x[-1]]) while abs(x[-1] - x[-2]) &gt; e: # 判断误差/精度值 n += 1 x.append(x[-1] - (f(x[-1]) / f1(x[-1]))) # 算法的核心，牛顿法迭代公式 table.add_row([n, x[-1]]) # 将结果画入表中if __name__ == '__main__': X = [float(input("请输入x0:"))] E = float(input("请输入误差(单位：x10e-5):")) E = E * (10 ** (-5)) newton(X, E) print("E = ", X[-1]-X[-2], "&lt; e = ", E) print("近似解：", X[-1]) print(table.draw()) 心得体会&emsp;&emsp;这次通过编程来实现了二分法、牛顿法、割线法、埃特金法、松弛法，使我能够运用数值计算方法，使用Python为工具编写出能够解决实际数学问题的程序，让我感觉很有成就感。]]></content>
      <tags>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门（一）]]></title>
    <url>%2F2018%2F03%2F14%2FPython%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法（一）]]></title>
    <url>%2F2018%2F03%2F14%2F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[绪论算法简介： 什么是算法？算法是定义良好的用来解决问题的步骤 算法是必不可少的 使用算法的原因：效率、抽象和重用性。 算法设计的一般方法： 随机法—&gt;依赖于随机数的统计特性—&gt;e.g.快速排序 分治法—&gt;分解、求解与合并—&gt;e.g.归并排序 动态规划—&gt;在动态规划中，不像分治法，子问题之间并不是独立的，可能有关联。 贪心法—&gt;贪心法在求解问题时总能做出在当前的最佳选择。（某种意义上的局部最优解）—&gt;e.g.霍夫曼编码 近似法—&gt;近似法并不计算出最优解，相反她只计算出“足够好”的解，通常用来解决计算成本高又因其十分有价值不愿放弃的问题。 软件工程： 模块化 可读性 简洁性 一致性 两个例子：调度问题与投资问题 考虑什么叫算法设计?调度问题 &emsp;&emsp;Q：有n项任务,每项任务加工时间已知。从0时刻开始陆续安排到一台机器上加工。每个任务的完成时间是从0时刻开始到任务加工截止的时间。求总完成时间（所有任务完成时间之和）最短的安排方案。 &emsp;&emsp; 实例：&emsp;&emsp;&emsp;&emsp;任务集 S={1,2,3,4,5}&emsp;&emsp;&emsp;&emsp;加工时间：t1=3 , t2=8 , t3=5 , t4=10 , t5=15 贪心法的解&emsp;&emsp;算法：按加工时间（3,8,5,10,15）从小到大安排 &emsp;&emsp;解：&emsp;&emsp;按算法，则顺序为：1，3，2，4，5。&emsp;&emsp;总完成时间：123t = 3+ 3+5+ 3+5+8+ 3+5+8+10+ 3+5+8+10+15 = 3x5+ 5x4+ 8x3+ 10x2+ 15 = 94 问题建模&emsp;&emsp;输入：&emsp;&emsp;&emsp;&emsp;任务集：S={1,2,...,n}，&emsp;&emsp;&emsp;&emsp;第j项任务加工时间:]]></content>
  </entry>
  <entry>
    <title><![CDATA[小梦岛祝您新年大吉]]></title>
    <url>%2F2018%2F02%2F16%2F%E5%B0%8F%E6%A2%A6%E5%B2%9B%E7%A5%9D%E6%82%A8%E6%96%B0%E5%B9%B4%E5%A4%A7%E5%90%89%2F</url>
    <content type="text"><![CDATA[☟ (●’◡’●) ☟如果没有自动播放，浏览全文前请先点击播放按钮（▶）播放音乐！ var options = {"narrow":false,"autoplay":true,"showlrc":3,"mode":"order","music":[{"title":"則夫と早苗","author":"平沢敦士","url":"/audios/則夫と早苗.mp3","pic":"http://p1.music.126.net/SsJ2bTC3ww1e2VyQ3Ityng==/7719671139635406.jpg","lrc":"/audios/lrc/則夫と早苗.lrc"},{"title":"春意红包","author":"三无MarBlue / 祖娅纳惜 / 泠鸢yousa / 小缘 / 洛萱 / 不才","url":"/audios/春意红包.mp3","pic":"http://p1.music.126.net/TVOFJLTlo7o1hOPewr5NwA==/109951162857898547.jpg","lrc":"/audios/lrc/春意红包.lrc"}]}; options.element = document.getElementById("aplayer0"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"/videos/dogs.mp4","pic":"/videos/vid_pic/2018.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() &emsp;&emsp;感谢您打开了这篇博文，2018年2月16日，大年初一。首先，我谨代表我和我的家人给您带来最真切的问候：春节好！ 时日平淡，而又温情如水。新的一年，目明心亮，立心力行。愿生活里有热汤和甜食，背包里有书本和远方。愿一切困难都能云淡风轻，每身孤独都拥抱共鸣。长夜里总有梦想发亮，秋收春耕。人海中常有良友相伴，长乐未央。所求皆如愿，所行化坦途，多喜乐，长安宁。 &emsp;&emsp;新年的钟声再次敲响，岁月的车又前进了一程。时间如同薄薄的流水，从生命里疾疾而过，回头望去，流水早已经冲走了昨日的足迹。向前看去，原来世界早已大不一样。 &emsp;&emsp;再次感谢您能够打开这篇博文。无论您是谁，您一定是我要感激的人。在我二十多年的生活中，是您给予了我帮助，是您促使我在通往未来的光明大路上一步步前行。不论您是我的家人、恩师或是朋友，您一定在和我相处的日子里肯定过我，激励过我，鞭策过我。 &emsp;&emsp;今年是狗年，狗(Dog)在英文中是一个很有趣的单词，有一句谚语说得好：”Don’t give up and try your best, I believe every dog has its day.” 这句话的意思是：不要放弃，继续努力，我相信每个人都会有成功的时候。说的没错，Every dog has its day. 新的一年里我将继续勇往直前，在我选择的道路上不忘初心，努力前行。 &emsp;&emsp;大年初一，送您一个福气满满的春意红包，一片翠色葱葱 明快又跳跃几瓣海棠山茶 花儿相映笑封着吉祥如意 幸福快来到红绳绕 拆开春意大红包 &emsp;&emsp;昨天在知乎上看到了这样一段话，很是喜欢。文章的最后把这段话拿出来送给你，愿您和您的家人幸福美满！ 愿你的长夜有星星，月光照黎明。愿你眼风如刀一样凌厉，唇角余留数不尽的温柔。愿总有人宠你像个孩子，有人会为你霜雪白头。新年愿你喜欢的人也喜欢你。爱你的人永远长留。愿你有小茶碗也有红酒杯，生活里有热汤也有甜酒。愿你能矜贵如公主，也能高冷成女王。所遇皆欢喜，所得皆善良。愿你新春已后，吉吉利利。百事都如意顺遂。得到的都是欢喜。镜里灯焰，挑岁寒枝，素梅傲雪。立春之后，春风入梦，烟雨朦胧。新年伊始，愿您福到窗棂事事欢；十分春色，破门来。一愿旧时过新春到，祝您万事都化小，小事都化了。二愿松柏不老傲梅独放，君身常健良辰好。]]></content>
  </entry>
  <entry>
    <title><![CDATA[English essay]]></title>
    <url>%2F2018%2F01%2F24%2FEnglish-essay%2F</url>
    <content type="text"><![CDATA[hello！ 第十七届全国英语创新大赛原文： &emsp;&emsp;With the pace of modern life becoming faster and faster [1] , the mobile phone has become an essential item in our daily life. The camera function of the mobile phone is most favorite function of most people [2] . Whenever we see beautiful scenery, special food [3] , or the warm situation in life, we will take out our mobile phone to take photos. &emsp;&emsp;However, another kind of behavior has became an obstacle to get along well with each other. Some people are always taking pictures whenever they eat, which is very impolite. These people who often take pictures at meal time always send those pictures to the circle of friends. Because the want the perfect appearence of the dishes, they don’t allowed their friends to eat before taking the perfect one. That makes their friends uncomfortable. &emsp;&emsp;Almost every time we eat together with others, the rhythm is disrupted, most of time we have to wait for their pictures although we are hungry. They do not only take pictures of special food, but also even the common food in life, like drinks, snacks, etc. which is boring and dull. &emsp;&emsp;This is very rude, I think [4] . Initially, they themselves enjoy the fun of taking photos, but ignore their friends’ emotions. They foget the original intention of enjoying the food. Secondly, they not only take photos, but also retouch them. During the long wait, the food has already cood [5], and eating them was not fresh enougth for the body [6] . What’s more, they are just absorbed in taking photos. Completely disregarding the communication with their peers during the meal. This make their friends feel bad. &emsp;&emsp;In my opinion, it’s best not to take photos with a mobile phone when you have a meal with a friend. It’s OK to see a special photo of a good meal, but please don’t take pictures at every meal [7] . Don’t take too long to take photos, instead [8] . You should put down your mobile phone. Please make dinner with your friends and give your friends the most basic respect [9] . 审题要求&emsp;&emsp;很显然，这是一篇漫画作文，题目要求要观察下面的图片，来“build a story”。要求不要简单地描述图片内容，而是应该去“create a story”，或者可以写一篇小论文来讨论图片中想要给你的信息。 思路&emsp;&emsp;接着我们来看图片，两个人在吃快餐，女孩在使用手机，男孩看起来有些生气。 &emsp;&emsp;按照我的理解，这可能是在说吃饭的时候玩手机引起别人不满，但是看了你的文章，我发现你的理解是吃饭前拍照晒朋友圈，我认为这也是可以的。 &emsp;&emsp;接下来，我们主要从你已经写好的文章下手，发现你文章中的错误，和更好的写作方式。 思路一其他人的文章&emsp;&emsp;首先，先让我们做一篇“阅读理解”，请你先阅读下面的一篇文章，如果遇到不认识的单词，可以快速通过网络搜索一下： &emsp;&emsp;It’s a Sunday night. You’re sitting down at the dinner table of your local restaurant, about to be served. The waiter circles around your table, placing each dish down one by one. You reach out to grab your favorite dish, before your sister yells at you to stop. &emsp;&emsp;She then proceeds to hold out her phone and take a picture of each dish. Rather than eating your food while it’s still hot, you’re forced to sit back and wait until she gets the perfect angle of each entree, smiling as if she is on the cusp of greatness, doing some sort of worldly service. This is a daily epidemic happening all over the country, and it needs to stop. Let the children eat! &emsp;&emsp;There used to be a time at the dinner table where a family could not proceed to eat until grace was said. Now, posting pictures to Instagram has become the standard pre-meal ritual. Rather than choosing between different prayers, we choose between different filters, making Lo-fi, Sierra and Hudson amongst others, our generation’s holy words. &emsp;&emsp;Why do people of Generation-Y find it necessary to constantly post pictures of their food? Have we become that food obsessed of a culture? I acknowledge that obesity has become an epidemic in our country, but do we really love our food so much that we need to digitally share it with everyone we know? More importantly, who gives a shit!? Speaking of shit… &emsp;&emsp;For every person that posts a picture of their food before they eat it, I think they should also post a picture of the effects after they eat it. Yes, I would be more intrigued and at least entertained by pictures of people’s bowel movements opposed to pictures of their dinners. &emsp;&emsp;And then they can even use their shitty filters on their shitty pictures! I’ll admit, there may be an occasion where something you eat is picture-worthy. If you are about to consume something intriguing like a cake in the shape of a giant penis, or a plate with a giant pigs head on it, then yes it’s appropriate to snap a picture to share. &emsp;&emsp;But when you are eating the same pasta fagioli as every other Joe Schmo in a 10-block radius, you can leave the camera in your pocket. I have more pictures of macaroni and cheese on my newsfeed than people! &emsp;&emsp;I can see it now, future Bar Mitzvah montages and family slide shows, consisting no longer of pictures of the family, but of every meal they have ever eaten. I can’t imagine how much anorexic and bulimic people must hate Instagram. Seeing so many pictures of food makes me want to throw up too. &emsp;&emsp;And it’s not just the picture taking that’s annoying, it’s the subsequent checking of the phone every five minutes for instant gratification that bugs me too. “Does everyone approve of my meal!?? I hope a lot of people like it!” I think some girls only “like” other girl’s food pics when it’s a picture of a heavy dish and they know that their “friend” is about to consume all the calories. “Yes, she’s gunna get fat! Eat up ya giant cow!! I want to be the skinniest of all!!” &emsp;&emsp;So if you are reading this article now, and you are one of these photo-taking perpetrators, or know someone close who is, I hope you have been inspired to right the wrong and get back to taking pictures of people rather than food. &emsp;&emsp;We shouldn’t have to wait until our food gets cold just because of your need for attention and acceptance. And if not, I look forward to seeing your shit pics soon! Tyler Gildin | Elite. &emsp;&emsp;看完了么？这篇文章可以说是写的很好了。作者开篇就像在将是一个故事一样：周日晚上，你坐在餐桌旁，服务员把菜一盘一盘地端上来，你看到了你最想吃的菜，却被姐姐大叫着制止了—她要干什么呢？这一段读了之后你有没有感觉你就是这个故事的主角呢？这就是作者写作的魔力在里面。因为作者用的是“YOU”，而不是someone else。 &emsp;&emsp;第二段故事继续，原来姐姐是要为每一盘菜拍一张完美的照片，上传到INS上。你只能坐下，看着热腾腾的食物等她拍完。接着，作者提出：这种现象已经很普遍了。此时，文章从特殊到一般，从个体到总体，最后一句“Let Children Eat!”感叹句，引发下一段的议论。 &emsp;&emsp;接下来作者就开始长篇大论了，虽然夹杂了一丢丢粗鄙的话语，但还是有道理的。结尾是明显的“呼吁体”。 &emsp;&emsp;Emmm，在了解了上面那篇文章作者的行文手法之后，接下来我们重点看一下你的文章。 你的文章修改建议： 1：这句话我明白你是再说“随着生活节奏的不断加快”，但是“faster and faster”在这里就不如“increase”来的高级，你可以改成“With the pace of life continuing to increase,”。2：手机的拍照功能被很多人喜欢，是这个意思吧？但是这样说有些别扭，我认为你可以 参考 ：In this digital age, people can take picture through many different devices such as smartphone, ipad, and tablet. Photography has become human interest nowadays.3：特殊的食物听起来不对，可以改成美味的食物，tasty。4：rude高频词汇，如果你用insolent，傲慢无礼。不仅粗鲁而且不尊重人。可能效果会更好，而rude ，粗鲁，指不礼貌，使人反感。显然insolent更“胜”一筹。另外，I think这一整个句子可以用改用 my perspective 引导。5：你是想用cold？我觉得cool比较合适。6：食物等的不新鲜：stale7：试着用each而不是every8：用一些俚语或许会锦上添花：ages/an age = a long time 很长时间9：这个结尾不太好，我认为应该去掉这一句，再加一些新的，你可以参考上面那篇文章的结尾（除了他的脏话。。） 思路二我的想法你也可以再写一两句“吃饭玩手机”这方面的，不过这只是我的想法，仅供参考！！ 接下来给你一些文章参考！！他们的观点可能和这个作业的观点不同/相反，主要是看他们用的句子，文章的结构。 https://theinkslingerstulc.weebly.com/features/3-reasons-you-should-take-food-picture-before-eat https://mobile.nytimes.com/2010/04/07/dining/07camera.html https://www.theguardian.com/lifeandstyle/wordofmouth/2013/mar/11/food-photography-is-it-ok http://www.bravotv.com/blogs/why-you-should%20take-photos-instagram-your-food-before-eating-marketing-study]]></content>
  </entry>
  <entry>
    <title><![CDATA[体验MultCloud实现云盘互转]]></title>
    <url>%2F2018%2F01%2F10%2F%E4%BD%BF%E7%94%A8MultCloud%E5%AE%9E%E7%8E%B0%E4%BA%91%E7%9B%98%E4%BA%92%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[你是否需要把一个云盘中的东西转移到另一个云盘？却又不想下载文件？MultCloud可以帮你！ &emsp;&emsp;今天，我来带领大家认识一款一个账号管理众多多云盘的在线服务：MultCloud。&emsp;&emsp;官网地址：MultCloud Free App for Managing Files and Transferring Files across Cloud Drives.&emsp;&emsp;——————MultCloud的宣传语 MultCloud是什么？&emsp;&emsp;MultCloud 是一款在线服务，可以在一个地方管理众多网盘，支持国产百度盘。 MultCloud能做什么？&emsp;&emsp;MultCloud可以实现一个账号管理多个云盘，提供分享功能、云盘间的同步功能、互传功能、上传下载文件功能等。 开始接触MultCloud了解MultCloud服务：&emsp;&emsp;首先在首页我们了解到MultCloud提供免费和付费两种服务，它们的对比如下：&emsp;&emsp;我们可以看到，免费版和付费版的区别在于： 初始流量： 免费版初始流量2TB，付费版无限流量。 但是免费版“可以通过分享 MultCloud 到社交网络，引荐其他人注册 MultCloud，使用 MultCloud 的分享功能来分享您的文件等方式来获取积分。1积分=10GB免费传输流量。” 多线程传输: 免费版双线程传输 付费版最高可达10个线程同时传输 服务器类型 免费版普通服务器 付费版VIP服务器 技术支持等级 免费版专业的技术支持 付费版更好的技术支持 支持同步方式 免费版2种同步方式（双向同步：在需要同步的两个云盘中添加，修改或删除任何云盘的文件都将会反映到另一个云盘。简单同步：只有在源目录中添加，修改和删除文件才会被反映到目标目录中。） 付费版8种同步方式（可执行”双向同步”、”简单同步”、”镜像同步”、”移动同步”、”累加同步”、”更新同步”、”增量备份同步”以及”完全备份同步”等八种同步方式。） 免费版和付费版都可以： 可添加无限数量的云盘账号 跨云盘数据传输 跨云盘数据同步 多云盘整合管理 付费版可以： 文件传输过滤（通过指定文件名或后缀，如：*.mp3|photo*|*Excel*等，传输指定文件。） 文件同步过滤 定时文件传输（预设传输任务，定时执行跨云盘文件传输。） 定时文件同步 主子账号管理 单向多目标文件同步（单向文件同步任务支持最多添加10个目标路径。）注册：&emsp;&emsp;MultCloud使用邮箱注册，也可以通过Google或Facebook登录。 &emsp;&emsp;登录后首先点击页面右面的添加云盘按钮添加云盘。以下是其支持的云盘列表： &emsp;&emsp;（可以看到MultCloud还支持FTP哦。 添加云盘：&emsp;&emsp;发现他竟然支持百度云，如果能够把百度云转移到Google Drive等其他云盘再来下载文件，是不是就可以躲过百度云限速的苦恼？所以首先我们试试百度云盘，选中并点击下一步后：&emsp;&emsp;我们注意到由于BaiDu云盘的限制，只能操作&quot;我的应用数据&quot; -&gt; &quot;lin1118&quot;目录下的文件或文件夹，所以我们以后需要在百度云里把我们想要操作的文件放到”我的应用数据” -&gt; “lin1118”目录下。&emsp;&emsp;修改好名称，点击添加百度云盘，将跳转到百度授权页面，登陆授权后即添加成功。&emsp;&emsp;其他云盘的添加方式应该是类似的，在这里省略了。我继续添加了谷歌云盘和微软云盘。 云盘列表&emsp;&emsp;添加完毕点击“云管理器”，我们可以查看我们刚刚添加的网盘了。 云盘服务的使用&emsp;&emsp;基本的上传下载分享功能就省略不提了。需要注意的是，经过我的测试，通过MultCloud直接下载百度云文件的速度比在百度云下载还慢，所以我建议还是使用它的云传输功能，把百度云转到Google Drive，在谷歌里下载就方便多了。另外，云同步由于目前我没有这种需求所以也不提了。 云传输功能&emsp;&emsp;使用云传输功能有两种途径： 通过点击菜单栏里的“云传输”按钮&emsp;&emsp;此种方式适合文件夹的传输，不支持文件的传输。 通过云盘文件列表&emsp;&emsp;在某个网盘的文件列表中选中一个或多个文件/文件夹,右键选择“复制到” 开始传输&emsp;&emsp;我们以我的百度云文件夹下测试用.pdf传输到谷歌云盘根目录为例来做个演示：&emsp;&emsp;使用第二种方法，将此文件复制到Google Drive：&emsp;&emsp;刚开始我传输文件时，发现等了几分钟，这个文件传输进度一直保持在0%不动。于是我测试了 Google Drive &lt;==> One Drive,发现马上传输就开始了。&emsp;&emsp;看来是百度云的问题。&emsp;&emsp;但是我没有放弃，等待了数分钟后，百度云到谷歌盘的任务突然开始了传输，并在较快时间内传输完毕：&emsp;&emsp;原来并不是不能传，而是需要等待。&emsp;&emsp;再来测试一个大文件试试：&emsp;&emsp;在等待了十多分钟后显示失败。查看原因提示： 1Cause: insufficient data written &emsp;&emsp;大文件传输失败？？？ 总结&emsp;&emsp;MultiCloud除百度云外的云盘互传速度还是挺快的，百度云和其他云盘之间互相传输小文件还行，大文件没戏。所以最后的结论：百度云牛逼。]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频点播]]></title>
    <url>%2F2018%2F01%2F09%2F%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD%2F</url>
    <content type="text"><![CDATA[ok Submit]]></content>
  </entry>
  <entry>
    <title><![CDATA[普通新闻]]></title>
    <url>%2F2018%2F01%2F06%2F%E6%99%AE%E9%80%9A%E6%96%B0%E9%97%BB%2F</url>
    <content type="text"><![CDATA[我的灵魂已经遭受了魔鬼的拷问，而天使从没有在寂寥黑暗的夜晚来到我的床前。 普通新闻作者/李纯 一&emsp;&emsp;黎小军在北京当了三年的快递员，负责常营地区一个分成6栋共22个单元的居民区，每天要送150件快递，打70通电话，有一辆黑色的上面挂了一个小型音箱的摩托车。他知道1栋5单元楼下有一个老头，喘气声音像风箱一样大，一年前死了老婆，每天和一条瞎了一只眼睛的拉布拉多坐在一楼的楼道里听收音机。而4栋10单元有个古怪的男人在客厅中间摆了一座很大的笼子，他每次敲门，那个男人只能非常生气地从笼子里走出来开门，然后迅速地回到笼子，叫黎小军自己把门关上。古怪男人的隔壁住着一对刚刚结婚的年轻人，家里散发着新鲜油漆和木料的味道。他告诉他的同事，小两口熬不过今年就要离婚啦。他这么笃定是因为上个礼拜他送快递时看见那个女的正在用手抠那个男的脸，黎小军是这么说的，男的鼻屎都被女的抠出来了。黎小军当初纯粹是因为送快递工资高，想存钱早点回老家结婚才干的。他在老家买了一套一百二十平的房子，每个月还三千块钱贷款，他用剩下的钱买了一份人寿保险和一点点股票。他有一个对性生活提不起什么兴趣的女朋友，大多数时候他是在出租房里看黄色碟片手淫解决的。 &emsp;&emsp;黎小军的生活本来没什么可讲的。直到他遇见李卉。 &emsp;&emsp;黎小军注意到李卉是2012年的秋天。每个礼拜，黎小军会收到一份寄给一位叫李卉的女人的快递。这个女人什么都在网上买。卫生纸、毛巾、茶杯，最多的是衣服、化妆品和包。有一次卸车，这位李女士的快递被卸货的一脚踢到地上，漏出来一根人造阴茎。他把它重新塞进箱子里，封好。 &emsp;&emsp;大部分时间李卉在上班，叫他把东西放在小区一楼的超市里，那里的老板娘总是板着一张又圆又扁的脸，抱着她三个月前生出来的儿子看《倚天屠龙记》。她总是不自觉地发出遭人嫌弃的鼻音很重的声音，她的儿子很不幸地遗传了她。送了三次以后，黎小军在一个月亮很圆的晚上见到了李卉。此后任何时刻，回忆起当时的每一处细节，他都能历历在目。他产生了万物停滞的哀伤的感觉，因为同时他也感到了这一停滞的短暂，感到了它的转瞬即逝，他难过得快要哭了出来。但他还是微笑着向对面的李女士说，“您好，这是您的快递，请问您需要验货吗？”李女士开口说话了，她的声音很低，有点沙哑，却饱含温柔，像雨后的风声。她说：“打开看看吧。” &emsp;&emsp;是一双浅口的银色皮鞋，她说：“你先别走，我试试看。”于是黎小军在她的对面站了一会儿，看着她又窄又白的脚伸进那双显然过于宽大的鞋子里，他从没有这么虔诚地盯着一位女士的脚看。他感到有些局促，双手不自然地放进了裤子口袋里，斜靠在门框上，这个姿势让他看上去像个绅士。 &emsp;&emsp;“买大了。”她说了一句。她请求这位一直对她微笑的，她猜想他应该是个非常乐观开朗的快递员，帮忙把鞋子丢到楼下的垃圾桶里。“不退货吗？”他有些担心地问。“打折买的，不退货。”她往后退了一步，果断地把门关上了。剩下这位前一秒表现得很快乐的快递员，在应急灯黄色光线的照耀下，叹了一口很重很重的气。如果李女士没有回到卧室，她一定能够听见这声叹息。 &emsp;&emsp;那天晚上，黎小军就着月光骑车回到了家。他的女朋友正坐在餐桌旁边等他吃饭。他的女朋友除了脸上有点小坑，可能是高中时治疗青春痘留下来的，身材有些不那么协调，她的腿和上身差不多长，以及在床上不是很活跃以外（确切地说压根没有主动干过些什么），从各方面看，她都是一个好相处的、无可挑剔的伴侣。黎小军进屋后，表现了伴侣应有的礼节。吻了一下她的脖子，把她的皮肤完全吸进嘴里，捏了捏她的屁股，问她是不是刚刚洗了澡，说闻到了她身上有薄荷的味道。他还看了眼桌上的菜，说宝贝，不用做这么多，晚上可以简单点。然后他从包里拿出一只崭新包装的盒子，说今天路过百盛的时候，突然想为她买点礼物。不过当他的女朋友惊喜地把脚伸进那双浅口银色皮鞋里，他却走进厨房盛饭了。接着，她的女朋友像个小鸟一样扑到他的怀里，他脑子里想的是另一个女人。他们吃完饭，看了会电视剧就睡觉了，没有做爱。 &emsp;&emsp;一切照旧。黎小军每天早上六点起床，去楼下一个墙壁发了霉，包子却蒸得又大又嫩的早点当买两个猪肉包子和一碗豆腐脑，然后一边骑车一边功放郑伊健的歌去公司。某个时间段，他的头发长到可以跟着风飘起来的长度，他可能是常营最有型的快递员了。要不是急着送快递，他就可以热心地载那些踩着小碎步赶地铁的姑娘一程了。他想任何一位穿高跟鞋的姑娘都会愿意坐上他的车的。可现在，他只能任那些需要帮助的姑娘们从他的小眼睛底下溜过去了。 &emsp;&emsp;过了半年，他发掘出可以令他的工作与众不同的事了。李卉的快递不仅每个礼拜如期而至，而且变本加厉。也可以这么说，他练就了在纷乱中一眼找到李卉的本事，他激动地把李卉的快递揽入怀中，“李卉，我又找到你啦。”李卉买得越来越多，有时她只是拆开看一眼，叫黎小军帮忙扔掉。黎小军好几次经过楼下，下意识地看一下垃圾桶，凑巧总能看见个把邮寄包装袋，粘在袋子上 的包裹完好无损，收件人是李卉。有时是家居用品，有时是一瓶香水，有时是一瓶洗面奶，没开封就直接扔在垃圾桶旁。黎小军便趁四下无人，有点心疼地捡起来，带回家。他想这个女人一定乏味得要死，只能依赖花钱填补自己的欲望。他见过太多有着强烈购物欲的女人，那些女人十个有九个嫁给了一个除了银行卡外一无是处的生意人。抛开瑜伽课和周末的下午茶聚会，她们最大的消遣就是花钱买各种各样的东西。但他觉得李卉和这些女人有很大的区别。他愿意承认第一眼见到她的时候就被她的美貌捕获了。他想李卉这么干可能因为她的内心掩埋了巨大的痛苦，他很愿意给予这份痛苦以理解。他开始摸出一些规律——周一到周五，晚上八点以后她准在，周末是上午十点到下午四点之间，晚上她很少在。这样黎小军常常能见到她了。 &emsp;&emsp;有时，她在涂指甲，她很小心并且极不情愿地开门，手指跷得高高的，像樱桃一样红的指甲油在她又白又小的手上流动。有时，她刚刚起床，穿露出脖子和胸部之间的一大截皮肤的睡衣，头发随意地丢在肩上，孩子一般地嘟着嘴，接下包裹。极少的时候，屋子里有另一个人，那个男人说，宝贝，你能不能把脾气放好点，不是每个人能够像我这样忍受你的。女人说，我就是这样，打开门对黎小军说，送得挺快。有时，黎小军会在楼下待一会儿，看她在阳台浇花。她那样小心翼翼地专心地浇花，好像那些花是她的孩子或者养的一只猫，她甚至用手反复抚摸一片叶子。李卉的阳台是整栋楼最茂盛的阳台，简直是一座小小的森林。 &emsp;&emsp;杀死李卉的那天，是2014年10月13日，日历上写的是诸事不宜。那时黎小军已经一个人住了。他的各方面看起来很不错的女朋友为他做了最后三个菜之后，突然提出分手。分手理由竟然是，她无法忍受他们之间乏善可陈的性生活。她说她遇到了一个男人，她第一次感受到真正意义上的高潮以后，就想结束他们这段关系了。她说，自己被打开了。这话让黎小军犯恶心。他想，她为什么不检讨一下他手淫的晚上她干吗去了。她要不在看《甄嬛传》，要不就睡着了。他用卫生纸擦大腿上的精液的时候还不忘擦擦她流在枕头巾上的口水。现在她竟然因为他给不了所谓的高潮而提出分手，并以近乎得道的口吻说，在另一个男人的身上发现了性的真谛。黎小军当时愤怒得差点把她摁在床上了，但他克制地坐在那儿，吃她做的炒菜。他明确无误地听见她说，“我想我不爱你。只是就这么混了几年。” &emsp;&emsp;那天风刮得出奇的大，逆风驶向小区的时候，大风把车的轮胎刮得转了个弯，黎小军险些撞上一个推着婴儿车的家庭妇女。那个家庭妇女粗鲁地骂了一句：“眼睛长到屁眼去啦。”婴儿车里的小孩倒是没有从睡梦中醒来。然后是中午十二点十五分，他在路边吃辣椒炒肉片的盒饭，他吃了足足五分钟，最后十秒钟也没有吃到肉片。接着，公司的管理员给他打了个电话，说他被一个客户投诉，客户说没收到东西，订单却显示签收了。黎小军说，不可能，凡是签收的，就一定送到。管理员叫他好好查查，叫他以后再不带脑子上班，干脆别来了。“反正现在想干快递的多着呢，不缺你这头猪！”黎小军说，不好意思，不好意思。他说话的时候，手上下摆来摆去，好像管理员站在他对面。他查了单号，发现送错了地方，看错门牌号了。他骂了一句，操，把盒饭扔在一棵大树底下，返回要货。他记得那个东西挺贵重的，好像是件艺术品，他费了很大的力气才把那件东西搬上去。收货的那个男人，递给他一根玉溪香烟，说他跑这么一趟不容易。那个男人笑起来两颗门牙间有一条很宽的牙缝，他想他吃东西一定很不方便。 可以预见，那个男人否认收过任何东西，他很凶地大声嚷道，你谁啊？随便敲我家门。黎小军骂了一句，操你妈的。那个男人打了黎小军一拳，黎小军朝他牙缝的那个位置回了一拳，他要让那条牙缝永远合不上。当天下午，黎小军被单位开除了。 &emsp;&emsp;那天晚上，他喝了很多很多酒。他晃晃悠悠地骑着摩托车，他搞不懂明明是回自己的家，为什么就到了李卉楼下。他稳健地停好车，用音箱开始放郑伊健，音量调到了最大档。他在楼下等了两首歌的时间，除了二楼的一个老伯朝他扔了一只鸡蛋，三楼的大妈对着他喊：“神经病啊！”就没有闹出什么动静。第三首播出前奏的时候，他按捺不住，跑上了七楼，急不可耐地敲了三遍门。李卉打开门，还没问出“有什么事吗”，黎小军一把抱住她，关上了门。他一遍又一遍地说：“李卉，我想死你了。”说完把李卉压在沙发上。李卉用手不停地抓他的脸、手臂和背，力气小得像一只蚂蚁。他从裤子后面的口袋掏出一把小刀，在她面前晃了晃，警告她不要动，他说：“我不会伤害你的。”可是这只蚂蚁还在左右冲撞地寻找出路，随后那把刀就划破了蚂蚁的脖子。黎小军说，那天他穿了一件白色的运动衫，染得通体血红，仿佛李卉全部的恨意印在了上面。 二&emsp;&emsp;事情发生半年后，我从北京市中级人民法院得知黎小军被判处死刑的消息。我的编辑叫我就此写一篇新闻，警告市民对那些喜欢敲门的快递员留个心眼。当时，我二十七岁，刚刚过了感怀多情的青年时代，不再因为采访了身世惨痛、眨巴着大眼睛的小姑娘，一边写稿一边掉眼泪了。这么说吧，在度过二十五岁那段极端低沉，不得不依靠安眠药睡觉的岁月后，我认为我的灵魂已经遭受了魔鬼的拷问，而天使从没有在寂寥黑暗的夜晚来到我的床前，用他们洁白的羽翼抚慰我颤抖的双手。2012年夏天的一个晚上，有个携刀的男人撬了我家的窗户，抢走了我的苹果手机和苹果电脑，和抽屉里的一千块钱。我才发现，我是多么渴望好好地活下去。活着多美妙。当我瑟瑟发抖地躲在被子里，我想的是，你想要什么都拿走吧，我只求活命。第二天，我没有报警，洗了个澡，吹风机吹了头发，开始满怀干劲地工作了。在有限的记者生涯里，我把我采访所得的一切都诚实而适度地公开在这份销量十五万份的报纸版面上了，考虑到读报的人越来越少，这个数字已经相当惊人了。 &emsp;&emsp;我在豆各庄的看守所第一次见到黎小军是宣判的半个月后。他比照片看起来更清秀，长了一对似蝴蝶的翅膀般的睫毛。他问我要了一根烟，一边吸一边说他吸不惯带薄荷的或者其他水果味的香烟，他说他进号子之前因为每天抽一包红塔山嗓子一直不太好，进了号子以后反而身体变强壮了。他说这儿比他想象的舒服一点，他没事喜欢听收音机，晚上9点有个香港金曲回放的节目，大概一个礼拜能听到一回郑伊健，听到9点半，他就睡觉了。他说他最近有点失眠，想到死感到害怕，挨到12点才睡着，整夜失眠的话，第二天劳动就没有力气。他开始对生命有种过分的敬畏，比如有个不知好歹的蜘蛛在他床头结了一张圆形的三四层厚的网，要是以前他就把它捏死了。他这样一口气说了十分钟以后，问我会不会写信。我想他一定很久没和人说过话，一个人太久没说话一旦开口，就会像他这样唠叨得停不下来。于是我说：“会的。我的女朋友在我写了十封情书以后，才同意和我出去看电影的。“他又问我要了一根烟，一边吸一边说，他真的吸不惯薄荷味的，叮嘱我下次记得带红塔山（好像我们有机会再见似的）。他说，喜欢写信的人不是很合群的人。他说他很希望我帮他写一封信，就像我为我的女朋友写的那些，这样他死后就能够带着这封信，交给李卉了。他说他不会写什么动人的东西，如果能，他就不会笨拙地把李卉压在沙发上了。他说他真的不知道除了拥抱和亲吻，还有什么办法表达他所想的。他说着说着，突然哭了起来，肩膀一上一下地颤抖，好像受了很大的委屈。我说，爱一个人不一定非得表达出来。 &emsp;&emsp;那天傍晚回到报社，我告诉我的编辑，我不想写“快递员入室杀人，独居女性网购有风险”之类的新闻了。我决定写一封信为黎小军补上一个结尾，但这样就有违你所强调的真实性的原则了。我的编辑说，如果每个记者像你一样，想给真实的生活增添浪漫的一笔的话，我们的读者盯着小说或者电视剧就行了，看新闻干什么呢？我点点头说，您说得很有道理，可是此时此刻，我就想这么干。我说，黎小军如果多认点字，就会偷偷地在李卉家的门缝底下塞上这样一封信，而我很愿意为他弥补这个遗憾。我还说了一句，虚构的真实比肉眼所见的真实更真实（这到底什么意思，连我自己都说不清）。信是这么写的： &emsp;&emsp;李女士， &emsp;&emsp;请原谅。我好像非常爱你。请容我先展开一番自我介绍，我叫黎小军，江苏人，今年28岁。我的职业是一名快递员，想必这一点你已十分清楚。我想让你知道，我不是一个寻常意义上的快递员，我想让你知道，每天站在门外等你开门，或者拨通你的电话，是一天中倍感幸福的时刻。在遇见你之前，我从不曾发觉，这个职业有什么美妙之处。 &emsp;&emsp;我交过一个女朋友，在不久前的某个晚上分手了。那天我的包里正好揣着你扔掉的一件法兰绒衬衫。如果你还记得，是一件卡其色的，很结实的衬衫，除了领口和袖子的线头有点杂乱，不过只要用剪刀小心翼翼地修剪就好。就像你修剪那些美丽的植物。我不清楚你为什么要丢掉它，为什么不在付款前进行哪怕一分钟的深思熟虑呢？顺便插一句，我正是被你弯腰浇花时的侧影深深地吸引了。 &emsp;&emsp;那天晚上，我打算把那件衣服送给我的女朋友，在我做出这个举动之前她就开始说些伤心话了。你扔掉的所有东西我都一一带回了家。如果某天你来做客，可能会为这里的一切感到惊讶。也可能是惊悚，觉得我是个变态。但我真心希望，你能产生哪怕像一根火柴那么细小的感动。 &emsp;&emsp;爱你是工作中唯一幸福的事，李女士。我的生活像永无止境却不断重复的齿轮，每天在同一个时间醒来，说出同样的问候，进行同样的反应，我和这个地方许多步伐匆匆的人一样，只是在巨大的孤独中活着罢了。 &emsp;&emsp;如果有一天，我想那一天大概像宇宙中转动的星球一样遥远，能够邀请你喝一杯咖啡，产生一些额外的交流。我很想看看你的嘴唇上方沾了点白色牛奶的样子，一定又滑稽又可爱。如果有幸去你家看看那些漂亮的植物，我想我会忍不住在那株水仙花前向你说出实情的。 责任编辑：阿芙拉]]></content>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大美介休]]></title>
    <url>%2F2018%2F01%2F06%2F%E5%A4%A7%E7%BE%8E%E4%BB%8B%E4%BC%91%2F</url>
    <content type="text"><![CDATA[大美介休 本文摘选自百度百科! &emsp;&emsp;介休市位于山西省腹地，太原盆地偏南，地理坐标东经111°44′10″——112°10′14″，北纬36°50′01″——37°11′04″，北、东北部分别与汾阳市、平遥县接壤，东南与沁源县毗邻，西南与灵石县相连，西北与孝义市相望。 blah blah blah &emsp;&emsp;介休市属于温带季风气候区，冬寒夏暑，四季分明。全市下辖5个街道、7个镇和3个乡，行政区域总面积744平方千米，总人口41.9万（2016年）。城镇化率64.3%，居山西省各县市第三位。 &emsp;&emsp;介休市因史出春秋时期割股奉君的介子推、东汉时期博通典籍的郭林宗和北宋时期出将入相五十载的文彦博三位贤士名达，素有“三贤故里”之称，文明史逾2800年。介休处于太原经济圈节点，与汾阳、孝义共同构成太原经济圈次中心，是国家园林城市 、国家卫生城市 、中国中部百强县（市）、中国清明（寒食）节文化之乡、全国文化先进市、全国体育先进市、全国科普示范市、全国计划生育优质服务县级示范点、山西省科教兴市先进单位、山西省历史文化名城、山西省双拥模范城市、山西省造林绿化先进市、山西省林业生态市、山西省增加农民收入先进市、中国中西部可持续发展最具竞争力的城市、中国中小城市科学发展百强县市、中国最具投资潜力的中小城市百强县市、山西省22个扩权强县试点县市之一 、阿里巴巴“千村万户”试点县市 、山西省资源型经济转型综合配套改革试验区先行试点 、第十一届人类学高级论坛圆桌论坛举办地 、中国中小城市新型城镇化质量百强县市。 &emsp;&emsp;介休被列为第一批国家新型城镇化综合试点地区。 介休市图片 表 1-1 # 中文名称 别名 著名景点 1 界休 绵山 2 介休 介州 张壁古堡 3 定阳 祆神楼 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 一级标题二级标题三级标题四级标题#####五级标题 ######六级标题 正文]]></content>
      <tags>
        <tag>说明文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
